タワーディフェンスゲーム  
※ゲームのプレイデータはdatファイルに保存するタイプ  
MySQLへ保存するタイプはこちら https://github.com/TT-3-14159265358979323846264338/defend_the_castle  
  
♦main構成♦  
src: ゲームで使用するソースフォルダ。単体テストを見据えてメソッドのアクセス修飾子をprivateからパッケージプライベートに変更中。その他単体テストしやすいように改良中。  
image: ゲームで使用する画像フォルダ。srcと同階層にimageフォルダを作成し、中身を保存すること。defaultは下書きのため、無くてもゲームに影響はない。  
test: 単体テスト用ソースフォルダ。srcと同階層にtestソースフォルダを作成し、中身を保存すること。現在作成中。  
other: その他ゲーム作成で使用するファイル。無くてもゲームに影響はない。  
pom.xml: Mavenプロジェクトの構成内容。  
  
♦制作背景♦  
元々ゲームが好きであるため、javaを学ぶ上での課題としてタワーディフェンスゲームを作成した。  
過去にもタワーディフェンスを作成したが、不用意にstatic変数を使用しすぎたことや  
継承をほとんど使用しなかったことでゲームの拡張性が皆無となってしまったため、再度作成しなおした。  
  
♦工夫♦  
過去の反省を生かして拡張性を重視した。  
各キャラやステージなどのデフォルトととなる情報は、abstractクラスを継承させたクラスに記載することで、記載漏れなく情報を定義させた。(パッケージ: defaultdata)  
ステータス計算などの各キャラで共通システムを1つのクラスにまとめ、これを継承することで、味方・設備・敵の情報を有したクラスを実装した。(クラス: battle.BattleData)  
これらの継承を使用することで、インスタンス作成時に継承元で定義することができ、メソッドの引数を共通化できた。  
  
マルチスレッドにすることによって一時停止処置をより正確に行えるようにした。  
swingのtimerでは一時停止と再スタートの処理を可能にしながら、次の遅延時間までの残り時間を測定できなかった。  
そのため、ScheduledExecutorService, CompletableFuture, waitを組み合わせることで、停止時の時刻や前回処理時の時間を計測しながら、一時停止後の再スタートを正確に処理できるようにした。(パッケージ: battle)  
また、マルチスレッドにすることで、数多のタイマーが並行処理となり、処理速度も向上した。  
ExecutorとFutureで使用するスレッド数はThreadPoolで事前に作成し、これを各クラスに渡すことでリソースの節約を行った。  
  
♦現在JUnit勉強中♦  
  
♦過去に作成した練習用プログラム♦  
https://github.com/TT-3-14159265358979323846264338/practice-code  
練習用なので、できは非常に悪いです。
